// Ergo and Alephium Token API Calls

// What do these functions do:
// The aim of these functions is to verify the validity of tokens on ergo or alephium by seeing that the token is
// authentic and is not a duplicate or fake.

// Who are these calls for:
// These calls are for anyone who wants to validate their users and their users want to validate their art. Can be used for token
// and nft manipulation.

// ${address}

//const address = address of user
//const tokenID = token_id (allows us to find original mint address)

// URL API Calls (Ergo)

//const url = `https://api.ergoplatform.com/api/v1/networkState`;
//const url = `https://api.ergoplatform.com/api/v1/boxes/byAddress/${address}`;
//const url = `https://api.ergoplatform.com/api/v1/addresses/${address}/balance/confirmed`
//const url_token = `https://api.ergoplatform.com/api/v0/assets/${tokenID}/issuingBox`

// URL API Calls (Alephium)

//const url = `https://wallet.mainnet.alephium.org/infos/version`; // current mainnet
//const url = `https://wallet.testnet.alephium.org/infos/version`; // current testnet

//global node = web3.setCurrentNodeProvider(<nodeURL>)

// Return Value for Functions (not important for you to know); if you need access to certain instances of the token these functions within this class will do it
export class NFTInfo {
  private valid: boolean;
  private nftName: string;
  private tokenId: string;
  private r9: string; // Ergo Specific otherwise "null"

  constructor(valid: boolean, nftName: string, tokenId: string, r9: string) {
    this.valid = valid;
    this.nftName = nftName;
    this.tokenId = tokenId;
    this.r9 = r9;
  }

  /**
   * 
   * @returns nftName (string)
   */
  getName(): string {
    return this.nftName;
  }

  /**
   * 
   * @returns valid (boolean)
   */
  getValid(): boolean {
    return this.valid;
  }

  /**
   * 
   * @returns tokenId (string)
   */
  getTokenID(): string {
    return this.tokenId;
  }

  /**
   * 
   * @returns r9 (string) (Ergo) ~ r9 is the Ergo Register to get the "ipfs" link to the nft image or token
   */
  getR9(): string {
    return this.r9;
  }

  /**
   * 
   * @returns (Ergo) returns a String to the ipfs image link
   */
  getImageLink(): String {
    let link = resolveIpfs(toUtf8String(this.r9).substring(2));
    return link;
  }
}

interface NFTs {
  ergollamas: NFTInfo[];

  addLLama(llama: NFTInfo): void;
  getLength(): number;
}

const nfts: NFTs = {
  ergollamas: [],

  addLLama(llama: NFTInfo): void {
    // Check if the llama already exists in the array
    const existingLlama = this.ergollamas.find(
      (existingLlama) => existingLlama.getTokenID() === llama.getTokenID()
    );

    if (!existingLlama) {
      this.ergollamas.push(llama);
    }
  },

  getLength(): number {
    return this.ergollamas.length;
  },
};



export async function getToken(address: string, mintAddress: string): Promise<NFTs | undefined> {
  const url = `https://api.ergoplatform.com/api/v1/addresses/${address}/balance/confirmed`;
  let validTokens = 0;

  nfts.ergollamas = [];

  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error('Error: Failed to retrieve data');
    }

    const data = await response.json();

    for (const token of data.tokens) {
      const ID = token.tokenId;
      let nftData = await checkMint(ID, mintAddress);
      if (nftData && nftData.getValid()) {
        nfts.addLLama(nftData);
        validTokens += 1;
      }
    }

    return nfts;
  } catch (error) {
    console.log("Error Encountered");
    return undefined;
  }
}

async function checkMint(tokenId: string, mintAddress: string): Promise<NFTInfo | undefined> {
  const urlToken = `https://api.ergoplatform.com/api/v0/assets/${tokenId}/issuingBox`;
  let isValid = false;

  let tokenID = "";
  let tokenName = "";
  let registry = "";

  try {
    const response = await fetch(urlToken);
    if (!response.ok) {
      throw new Error('Error: Failed to retrieve data');
    }

    const data = await response.json();

    const firstEntry = data[0];

    const address = firstEntry.address;

    if (mintAddress === address) {
      console.log("| Accepted |", firstEntry.assets[0].name, " | ", firstEntry.assets[0].tokenId, " |");

      tokenName = firstEntry.assets[0].name;
      tokenID = firstEntry.assets[0].tokenId;
      registry = firstEntry.additionalRegisters.R9;

      isValid = true;
    } else {
      console.log("| Denied |", firstEntry.assets[0].name);
    }

    let nftReturn = new NFTInfo(isValid, tokenName, tokenID, registry);

    return nftReturn;
  } catch (error) {
    console.log("Error Encountered");
    return undefined;
  }
}

// 
export function resolveIpfs(url: string): String {
  const ipfsPrefix = 'ipfs://';
  if (!url.startsWith(ipfsPrefix)) return url;
  else return url.replace(ipfsPrefix, 'https://cloudflare-ipfs.com/ipfs/');
}

// R9 -> HEX -> String
export function toUtf8String(hex:string): String {
  if(!hex){
    hex = ''
  }
    var str = '';
    for (var i = 0; i < hex.length; i += 2) {
      str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    }
    return str;
}

